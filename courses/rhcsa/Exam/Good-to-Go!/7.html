<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>RHCSA Exam Lab 7: Swap Partition Configuration</title>
    <style>
        :root {
            --redhat-red: #cc0000;
            --redhat-dark: #1e1e1e;
            --redhat-light: #f0f0f0;
            --redhat-accent: #4CAF50;
            --redhat-blue: #007ACC;
            --panel-bg: #252525;
            --terminal-bg: #000;
            --border-color: #444;
            --current-step: #3a3a3a;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Red Hat Text', 'Overpass', sans-serif;
            background-color: var(--redhat-dark);
            color: var(--redhat-light);
            margin: 0;
            padding: 0;
            line-height: 1.6;
            height: 100vh;
            overflow: hidden;
        }
        
        .lab-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 100%;
            margin: 0;
            background: var(--redhat-dark);
        }
        
        .header {
            background: linear-gradient(to right, #1e1e1e, #333);
            padding: 15px 20px;
            color: white;
            display: flex;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .header img {
            height: 30px;
            margin-right: 15px;
        }
        
        .header h1 {
            margin: 0;
            font-size: 1.5em;
            font-weight: normal;
        }
        
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .guide-panel {
            width: 50%;
            padding: 20px;
            background: var(--panel-bg);
            overflow-y: auto;
            border-right: 1px solid var(--border-color);
        }
        
        .terminal-panel {
            width: 50%;
            display: flex;
            flex-direction: column;
            background: var(--panel-bg);
            position: relative;
        }
        
        .guide h2 {
            margin-top: 0;
            color: var(--redhat-accent);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }
        
        .lab-intro {
            background: rgba(76, 175, 80, 0.1);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border-left: 4px solid var(--redhat-accent);
        }
        
        .lab-intro h3 {
            margin-top: 0;
            color: var(--redhat-accent);
        }
        
        .requirements-panel {
            background: #2a2a2a;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
            border-left: 4px solid var(--redhat-red);
        }
        
        .requirements-panel h4 {
            margin-top: 0;
            color: var(--redhat-red);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }
        
        .requirement-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            padding: 8px;
            background: #252525;
            border-radius: 3px;
        }
        
        .requirement-item.completed {
            border-left: 3px solid var(--redhat-accent);
        }
        
        .requirement-item.partial {
            border-left: 3px solid #FFD700;
        }
        
        .requirement-checkbox {
            margin-right: 10px;
            color: var(--redhat-accent);
            min-width: 20px;
            text-align: center;
        }
        
        .requirement-label {
            flex: 1;
        }
        
        .guide-step {
            margin-bottom: 15px;
            padding: 15px;
            background: #333;
            border-left: 4px solid var(--redhat-blue);
            position: relative;
        }
        
        .guide-step.current {
            background: var(--current-step);
            border-left: 4px solid var(--redhat-accent);
        }
        
        .guide-step.completed {
            opacity: 0.7;
            border-left: 4px solid #666;
        }
        
        .guide-step h3 {
            margin-top: 0;
            color: var(--redhat-accent);
            display: flex;
            align-items: center;
        }
        
        .step-number {
            background: var(--redhat-accent);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-size: 0.8em;
        }
        
        .step-status {
            margin-left: auto;
            font-size: 0.8em;
            padding: 3px 8px;
            border-radius: 3px;
        }
        
        .status-pending {
            background: #555;
            color: #ccc;
        }
        
        .status-current {
            background: var(--redhat-blue);
            color: white;
        }
        
        .status-completed {
            background: var(--redhat-accent);
            color: white;
        }
        
        .required-command {
            background: rgba(76, 175, 80, 0.1);
            padding: 10px;
            border-radius: 3px;
            margin: 10px 0;
            border-left: 3px solid var(--redhat-accent);
        }
        
        .command-hint {
            background: #2a2a2a;
            padding: 10px;
            border-radius: 3px;
            margin: 10px 0;
            border-left: 3px solid var(--redhat-blue);
            font-family: 'Red Hat Mono', monospace;
        }
        
        .concept {
            background: #2a2a2a;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            border-left: 4px solid var(--redhat-blue);
        }
        
        .concept h4 {
            margin-top: 0;
            color: var(--redhat-blue);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }
        
        .concept-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .concept-item {
            background: #252525;
            padding: 10px;
            border-radius: 5px;
            border-left: 2px solid var(--redhat-red);
        }
        
        .concept-item strong {
            color: var(--redhat-red);
            display: block;
            margin-bottom: 5px;
        }
        
        .terminal {
            background: var(--terminal-bg);
            padding: 15px;
            flex: 1;
            overflow-y: auto;
            font-family: 'Red Hat Mono', monospace;
        }
        
        .command-line {
            display: flex;
            align-items: center;
            padding: 15px;
            background: #333;
            border-top: 1px solid var(--border-color);
            margin-top: auto;
            flex-shrink: 0;
            position: relative;
        }
        
        #command-input {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--redhat-light);
            font-family: 'Red Hat Mono', monospace;
            font-size: 16px;
            outline: none;
            padding: 8px;
        }
        
        .prompt {
            color: var(--redhat-accent);
            white-space: nowrap;
            margin-right: 5px;
        }
        
        .file-content {
            background: #1e1e1e;
            padding: 10px;
            border-radius: 3px;
            font-family: 'Red Hat Mono', monospace;
            white-space: pre;
            overflow-x: auto;
            margin: 10px 0;
        }
        
        .file-path {
            color: var(--redhat-blue);
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        code {
            background: #1e1e1e;
            padding: 2px 5px;
            border-radius: 3px;
            color: var(--redhat-accent);
            font-family: 'Red Hat Mono', monospace;
        }
        
        kbd {
            background: #444;
            padding: 2px 5px;
            border-radius: 3px;
            color: white;
            font-family: 'Red Hat Mono', monospace;
        }
        
        .success {
            color: var(--redhat-accent);
            font-weight: bold;
        }
        
        .error {
            color: #FF5252;
        }
        
        .warning {
            color: #FFD700;
            font-weight: bold;
        }
        
        .completion-message {
            background: rgba(76, 175, 80, 0.2);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            margin: 20px 0;
            border: 1px solid var(--redhat-accent);
        }
        
        .progress-bar {
            height: 5px;
            background: #333;
            border-radius: 3px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--redhat-accent);
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .hint-box {
            background: rgba(255, 215, 0, 0.1);
            border-left: 4px solid #FFD700;
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
        }
        
        .tab-completion {
            position: absolute;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 3px;
            max-height: 150px;
            overflow-y: auto;
            z-index: 100;
            font-family: 'Red Hat Mono', monospace;
            font-size: 14px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            bottom: 100%;
            left: 0;
            right: 0;
            margin-bottom: 5px;
        }
        
        .tab-completion-item {
            padding: 5px 10px;
            cursor: pointer;
        }
        
        .tab-completion-item:hover, .tab-completion-item.selected {
            background: #007ACC;
            color: white;
        }
        
        .vim-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .vim-container {
            display: flex;
            width: 90%;
            height: 80%;
            gap: 20px;
        }
        
        .vim-instructions {
            width: 30%;
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            overflow-y: auto;
        }
        
        .vim-instructions h3 {
            margin-top: 0;
            color: var(--redhat-accent);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }
        
        .vim-editor {
            width: 70%;
            background: #1e1e1e;
            border: 1px solid #444;
            display: flex;
            flex-direction: column;
            font-family: 'Red Hat Mono', monospace;
        }
        
        .vim-header {
            background: #333;
            padding: 5px 10px;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .vim-content {
            flex: 1;
            padding: 10px;
            overflow: auto;
            white-space: pre;
            color: #ccc;
            position: relative;
        }
        
        .vim-command-line {
            display: flex;
            background: #333;
            padding: 5px;
            border-top: 1px solid #444;
        }
        
        .vim-prompt {
            color: #4CAF50;
            padding: 0 5px;
        }
        
        .vim-input {
            flex: 1;
            background: transparent;
            border: none;
            color: white;
            font-family: 'Red Hat Mono', monospace;
            outline: none;
        }
        
        .vim-status {
            background: #333;
            padding: 3px 10px;
            color: #ccc;
            font-size: 0.9em;
            border-top: 1px solid #444;
            display: flex;
            justify-content: space-between;
        }
        
        .vim-mode-indicator {
            color: #FFD700;
        }
        
        .vim-cursor {
            display: inline-block;
            width: 8px;
            height: 16px;
            background: #ccc;
            animation: blink 1s infinite;
            vertical-align: middle;
        }
        
        .vim-esc-button {
            background: #555;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin-left: 10px;
        }
        
        .vim-esc-button:hover {
            background: #666;
        }
        
        .vim-command-buttons {
            display: flex;
            gap: 10px;
        }
        
        .vim-command-button {
            background: #444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .vim-command-button:hover {
            background: #555;
        }
        
        .vim-mode-indicator.command-mode {
            color: #FFD700;
        }
        
        .vim-mode-indicator.insert-mode {
            color: #4CAF50;
        }
        
        .vim-textarea {
            position: absolute;
            top: 10px;
            left: 10px;
            width: calc(100% - 20px);
            height: calc(100% - 20px);
            background: transparent;
            border: none;
            color: #ccc;
            font-family: 'Red Hat Mono', monospace;
            resize: none;
            outline: none;
            white-space: pre;
            overflow: auto;
            caret-color: #ccc;
        }
        
        .vim-readonly-textarea {
            position: absolute;
            top: 10px;
            left: 10px;
            width: calc(100% - 20px);
            height: calc(100% - 20px);
            background: transparent;
            border: none;
            color: #ccc;
            font-family: 'Red Hat Mono', monospace;
            resize: none;
            outline: none;
            white-space: pre;
            overflow: auto;
            pointer-events: none;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        @media (max-width: 992px) {
            .main-content {
                flex-direction: column;
            }
            
            .guide-panel, .terminal-panel {
                width: 100%;
                height: 50%;
            }
            
            .vim-container {
                width: 95%;
                height: 90%;
                flex-direction: column;
            }
            
            .vim-instructions, .vim-editor {
                width: 100%;
            }
            
            .vim-instructions {
                height: 30%;
            }
            
            .vim-editor {
                height: 70%;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Red+Hat+Text:wght@400;700&family=Red+Hat+Mono&display=swap" rel="stylesheet"/>
</head>
<body>
<div class="lab-container">
    <div class="header">
        <img alt="Red Hat Logo" src="https://www.redhat.com/profiles/rh/themes/redhatdotcom/img/logo.svg"/>
        <h1>RHCSA Exam Lab 7: Swap Partition Configuration</h1>
    </div>
    
    <div class="main-content">
        <div class="guide-panel">
            <h2>Lab Instructions</h2>
            
            <div class="lab-intro">
                <h3>Lab Objective</h3>
                <p>Create and configure a 2G swap partition on your system. You will need to create the partition, set its type, format it as swap, activate it, and configure it to mount automatically at boot without affecting the original swap partition.</p>
                <p><strong>Time Estimate:</strong> 15-20 minutes</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
                <div id="progress-text">0% Complete</div>
            </div>

            <div class="requirements-panel">
                <h4>Swap Partition Requirements</h4>
                <div class="requirement-item" id="req-partition-created">
                    <span class="requirement-checkbox">‚òê</span>
                    <span class="requirement-label">Create a 2G swap partition on <code>/dev/sda</code></span>
                </div>
                <div class="requirement-item" id="req-partition-type">
                    <span class="requirement-checkbox">‚òê</span>
                    <span class="requirement-label">Set partition type to Linux swap (82)</span>
                </div>
                <div class="requirement-item" id="req-mkswap">
                    <span class="requirement-checkbox">‚òê</span>
                    <span class="requirement-label">Format partition as swap with <code>mkswap</code></span>
                </div>
                <div class="requirement-item" id="req-swapon">
                    <span class="requirement-checkbox">‚òê</span>
                    <span class="requirement-label">Activate swap with <code>swapon</code></span>
                </div>
                <div class="requirement-item" id="req-fstab">
                    <span class="requirement-checkbox">‚òê</span>
                    <span class="requirement-label">Add entry to <code>/etc/fstab</code> for automatic mounting</span>
                </div>
            </div>

            <div class="guide-step completed" id="step0">
                <h3>
                    <span class="step-number">0</span>
                    Lab Introduction
                    <span class="step-status status-completed">Completed</span>
                </h3>
                <p>Welcome to the RHCSA Swap Partition Configuration Lab. In this lab, you will create and configure a swap partition on a Red Hat Enterprise Linux system without affecting the original swap partition.</p>
                <p>Follow the steps in order. You must complete each step before moving to the next one.</p>
            </div>

            <div class="guide-step current" id="step1">
                <h3>
                    <span class="step-number">1</span>
                    Create Partition with fdisk
                    <span class="step-status status-current">Current Step</span>
                </h3>
                <p>Start by launching fdisk to create a new partition on <code>/dev/sda</code>:</p>
                
                <div class="hint-box">
                    <strong>Type this command exactly:</strong>
                </div>
                
                <div class="command-hint">
                    fdisk /dev/sda
                </div>
                
                <p>Once in fdisk, follow these steps:</p>
                <ol>
                    <li>Type <code>p</code> to view the current partition table</li>
                    <li>Type <code>n</code> to create a new partition</li>
                    <li>Press <code>Enter</code> to accept default partition type (primary)</li>
                    <li>Press <code>Enter</code> to accept default partition number</li>
                    <li>Press <code>Enter</code> to accept default first sector</li>
                    <li>Type <code>+2G</code> for the last sector to create a 2G partition</li>
                    <li>Type <code>t</code> to change partition type</li>
                    <li>Type <code>l</code> to list known partition types</li>
                    <li>Type <code>82</code> to set partition type to Linux swap</li>
                    <li>Type <code>w</code> to write changes and exit</li>
                </ol>

                <div class="concept">
                    <h4>Understanding fdisk Commands</h4>
                    <p>fdisk is a command-line utility for managing disk partitions. Key commands used:</p>
                    <ul>
                        <li><code>p</code> - Print partition table</li>
                        <li><code>n</code> - Create new partition</li>
                        <li><code>t</code> - Change partition type</li>
                        <li><code>l</code> - List known partition types</li>
                        <li><code>w</code> - Write changes to disk</li>
                    </ul>
                </div>
            </div>

            <div class="guide-step" id="step2">
                <h3>
                    <span class="step-number">2</span>
                    Update Kernel Partition Table
                    <span class="step-status status-pending">Pending</span>
                </h3>
                <p>After creating the partition, update the kernel's partition table:</p>
                
                <div class="hint-box">
                    <strong>Type these commands exactly:</strong>
                </div>
                
                <div class="command-hint">
                    partx -a /dev/sda
                </div>
                
                <div class="command-hint">
                    partprobe
                </div>
                
                <p class="warning">Note: The new partition should be <code>/dev/sda8</code> (or similar depending on your setup).</p>

                <div class="concept">
                    <h4>Why Update Kernel Partition Table?</h4>
                    <p>When you create a new partition, the kernel needs to be informed about it. These commands make the new partition visible to the system without requiring a reboot.</p>
                </div>
            </div>

            <div class="guide-step" id="step3">
                <h3>
                    <span class="step-number">3</span>
                    Format as Swap Space
                    <span class="step-status status-pending">Pending</span>
                </h3>
                <p>Format the new partition as swap space:</p>
                
                <div class="hint-box">
                    <strong>Type this command exactly:</strong>
                </div>
                
                <div class="command-hint">
                    mkswap /dev/sda8
                </div>
                <p class="warning">Replace <code>sda8</code> with your actual partition number if different</p>

                <div class="concept">
                    <h4>Understanding mkswap</h4>
                    <p>The <code>mkswap</code> command formats a partition as swap space. It creates a swap signature and prepares the partition for use as virtual memory.</p>
                    <p>After running <code>mkswap</code>, you'll see output showing the UUID of the new swap space. Copy this UUID for the next step.</p>
                </div>
            </div>

            <div class="guide-step" id="step4">
                <h3>
                    <span class="step-number">4</span>
                    Activate Swap Space
                    <span class="step-status status-pending">Pending</span>
                </h3>
                <p>Activate the new swap partition:</p>
                
                <div class="hint-box">
                    <strong>Type this command exactly:</strong>
                </div>
                
                <div class="command-hint">
                    swapon -a
                </div>
                
                <div class="hint-box">
                    <strong>Verify activation:</strong>
                </div>
                
                <div class="command-hint">
                    swapon -s
                </div>
                <p>You should see both the original swap and your new 2G swap listed.</p>

                <div class="concept">
                    <h4>Temporary vs Persistent Activation</h4>
                    <p>The <code>swapon -a</code> command activates all swap partitions listed in <code>/etc/fstab</code>. To make it persistent across reboots, you must add an entry to <code>/etc/fstab</code>.</p>
                </div>
            </div>

            <div class="guide-step" id="step5">
                <h3>
                    <span class="step-number">5</span>
                    Configure Persistent Mounting
                    <span class="step-status status-pending">Pending</span>
                </h3>
                <p>Edit <code>/etc/fstab</code> to enable automatic swap activation at boot:</p>
                
                <div class="hint-box">
                    <strong>Get the UUID of your swap partition:</strong>
                </div>
                
                <div class="command-hint">
                    blkid /dev/sda8
                </div>
                <p class="warning">Replace <code>sda8</code> with your actual partition number</p>
                <p>Copy the UUID from the output.</p>
                
                <div class="hint-box">
                    <strong>Edit /etc/fstab:</strong>
                </div>
                
                <div class="command-hint">
                    vim /etc/fstab
                </div>
                
                <p>Add a line like this (using your actual UUID):</p>
                
                <div class="file-content">UUID=xxxx-xxxx-xxxx-xxxx none swap sw 0 0</div>
                
                <p>To save and exit vim:</p>
                <ol>
                    <li>Press <code>ESC</code> to ensure you're in command mode</li>
                    <li>Type <code>:wq</code> and press <code>Enter</code> to write and quit</li>
                </ol>

                <div class="concept">
                    <h4>Understanding /etc/fstab</h4>
                    <p>The <code>/etc/fstab</code> file controls what filesystems are mounted at boot. Each line has six fields:</p>
                    <ol>
                        <li><strong>Device:</strong> UUID (recommended for swap)</li>
                        <li><strong>Mount point:</strong> <code>none</code> for swap</li>
                        <li><strong>Filesystem type:</strong> <code>swap</code></li>
                        <li><strong>Options:</strong> <code>sw</code> for swap</li>
                        <li><strong>Dump:</strong> <code>0</code> (not used for swap)</li>
                        <li><strong>Fsck order:</strong> <code>0</code> (no filesystem check for swap)</li>
                    </ol>
                </div>
            </div>

            <div class="guide-step" id="step6">
                <h3>
                    <span class="step-number">6</span>
                    Final Verification
                    <span class="step-status status-pending">Pending</span>
                </h3>
                <p>Verify that all configurations are working correctly:</p>
                
                <div class="hint-box">
                    <strong>Type these commands one by one:</strong>
                </div>
                
                <div class="command-hint">
                    swapon -s
                </div>
                <p>Should show both swap partitions</p>
                
                <div class="command-hint">
                    free -h
                </div>
                <p>Should show total swap as original + 2G</p>
                
                <div class="command-hint">
                    cat /etc/fstab
                </div>
                <p>Should show your new swap entry with UUID</p>

                <div class="concept">
                    <h4>Verification Commands</h4>
                    <p>After making changes, always verify with these commands:</p>
                    <ul>
                        <li><code>swapon -s</code> - Shows active swap partitions</li>
                        <li><code>free -h</code> - Displays memory and swap usage</li>
                        <li><code>cat /etc/fstab</code> - Shows fstab configuration</li>
                    </ul>
                </div>
            </div>
            
            <div class="concept">
                <h4>Understanding Swap Space</h4>
                <div class="concept-grid">
                    <div class="concept-item">
                        <strong>What is Swap?</strong>
                        Swap space is used when the system's physical RAM is full. It acts as an overflow area, moving less-used memory pages to disk.
                    </div>
                    <div class="concept-item">
                        <strong>Swap Partition vs Swap File</strong>
                        Swap partitions are dedicated disk partitions for swap, while swap files are regular files configured as swap space.
                    </div>
                    <div class="concept-item">
                        <strong>Swap Management</strong>
                        <code>swapon</code> - Activates swap space<br>
                        <code>swapoff</code> - Deactivates swap space<br>
                        <code>swapon -s</code> - Shows current swap usage
                    </div>
                    <div class="concept-item">
                        <strong>Persistence</strong>
                        To make swap persistent across reboots, entries must be added to <code>/etc/fstab</code> using either device path or UUID.
                    </div>
                </div>
            </div>
            
            <div id="completion-message" class="completion-message" style="display: none;">
                <h3>üéâ Lab Completed Successfully!</h3>
                <p>All swap partition requirements have been met.</p>
                <p>You can now proceed to the next lab.</p>
            </div>
        </div>
        
        <div class="terminal-panel">
            <div class="terminal" id="terminal-output">
                <div><span class="prompt">[root@station ~]#</span> Welcome to RHCSA Lab 7: Swap Partition Configuration</div>
                <div><span class="prompt">[root@station ~]#</span> This is a guided lab. Follow the instructions on the left.</div>
                <div><span class="prompt">[root@station ~]#</span> You must complete each step in order.</div>
                <div><span class="prompt">[root@station ~]#</span> Current step: Create Partition with fdisk</div>
                <div><span class="prompt">[root@station ~]#</span> Type: <code>fdisk /dev/sda</code></div>
                <div><span class="prompt">[root@station ~]#</span> <span class="success">Tip:</span> Press <code>Tab</code> for command and path completion</div>
            </div>
            <div class="command-line">
                <span class="prompt">[root@station ~]#</span>
                <input autofocus id="command-input" placeholder="Type the command shown in the current step..." type="text"/>
                <div id="tab-completion" class="tab-completion" style="display: none;"></div>
            </div>
        </div>
    </div>
</div>

<!-- Vim Editor Overlay -->
<div id="vim-overlay" class="vim-overlay" style="display: none;">
    <div class="vim-container">
        <div class="vim-instructions" id="vim-instructions">
            <h3>Vim Editor Instructions</h3>
            <div id="vim-instructions-content"></div>
        </div>
        
        <div class="vim-editor">
            <div class="vim-header">
                <span id="vim-filename">filename</span>
                <div class="vim-command-buttons">
                    <button class="vim-command-button" id="vim-insert-button">i (Insert)</button>
                    <button class="vim-esc-button" id="vim-esc-button">ESC</button>
                    <span id="vim-close-btn" style="cursor: pointer; margin-left: 10px;">√ó</span>
                </div>
            </div>
            <div class="vim-content" id="vim-content">
                <textarea id="vim-textarea" class="vim-textarea" spellcheck="false" style="display: none;"></textarea>
                <div id="vim-readonly" class="vim-readonly-textarea"></div>
            </div>
            <div class="vim-command-line">
                <input type="text" class="vim-input" id="vim-input" placeholder="Type :wq to save and exit"/>
            </div>
            <div class="vim-status">
                <span class="vim-mode-indicator command-mode" id="vim-mode-indicator">COMMAND MODE</span>
                <span id="vim-cursor-position">1,1</span>
            </div>
        </div>
    </div>
</div>

<script>
    const commandInput = document.getElementById('command-input');
    const terminalOutput = document.getElementById('terminal-output');
    const requirementItems = document.querySelectorAll('.requirement-item');
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');
    const completionMessage = document.getElementById('completion-message');
    const steps = document.querySelectorAll('.guide-step');
    const tabCompletion = document.getElementById('tab-completion');
    
    // Vim editor elements
    const vimOverlay = document.getElementById('vim-overlay');
    const vimInstructions = document.getElementById('vim-instructions');
    const vimInstructionsContent = document.getElementById('vim-instructions-content');
    const vimFilename = document.getElementById('vim-filename');
    const vimContent = document.getElementById('vim-content');
    const vimTextarea = document.getElementById('vim-textarea');
    const vimReadonly = document.getElementById('vim-readonly');
    const vimInput = document.getElementById('vim-input');
    const vimModeIndicator = document.getElementById('vim-mode-indicator');
    const vimCursorPosition = document.getElementById('vim-cursor-position');
    const vimCloseBtn = document.getElementById('vim-close-btn');
    const vimEscButton = document.getElementById('vim-esc-button');
    const vimInsertButton = document.getElementById('vim-insert-button');
    
    let commandHistory = [];
    let historyIndex = -1;
    let currentStep = 1;
    let tabCompletionIndex = -1;
    let tabCompletionItems = [];
    let lastTabInput = '';
    
    // Track which commands have been executed for each step
    const stepCommandsExecuted = {
        2: { 'partx': false, 'partprobe': false },
        4: { 'swapon-a': false, 'swapon-s': false },
        6: { 'swapon-s': false, 'free-h': false, 'cat-fstab': false }
    };
    
    // Available commands for tab completion
    const availableCommands = [
        'fdisk', 'partx', 'partprobe', 'mkswap', 'swapon', 'blkid', 'vim', 'cat', 'free', 'clear', 'help'
    ];
    
    // Available file paths for tab completion
    const filePaths = {
        '/dev/': ['sda', 'sdb', 'sdc'],
        '/etc/': ['fstab']
    };
    
    // Track configuration state
    const configState = {
        partitionCreated: false,
        partitionType: false,
        mkswap: false,
        swapon: false,
        fstab: false
    };
    
    // Expected commands for each step
    const stepCommands = {
        1: ['fdisk /dev/sda'],
        2: ['partx -a /dev/sda', 'partprobe'],
        3: ['mkswap /dev/sda8', 'mkswap /dev/sda'],
        4: ['swapon -a', 'swapon -s'],
        5: ['blkid /dev/sda8', 'blkid /dev/sda', 'vim /etc/fstab'],
        6: ['swapon -s', 'free -h', 'cat /etc/fstab']
    };
    
    // Simulated file contents
    let fstabContent = `# /etc/fstab
UUID=1234-5678 / ext4 defaults 1 1
UUID=abcd-efgh /boot ext4 defaults 1 2
UUID=ijkl-mnop swap swap defaults 0 0
`;
    
    // Vim editor state
    let vimState = {
        file: '',
        content: '',
        cursorPos: 0,
        mode: 'command', // 'command' or 'insert'
        isEditing: false,
        fileType: '',
        initialContent: ''
    };
    
    // Track fdisk state
    let fdiskState = {
        inFdisk: false,
        step: 0,
        partitionNumber: 8 // Default partition number
    };
    
    const commands = {
        'fdisk': (args) => {
            if (args[0] === "/dev/sda") {
                if (currentStep === 1 || currentStep > 1) {
                    fdiskState.inFdisk = true;
                    fdiskState.step = 0;
                    completeStep(1);
                    return `Welcome to fdisk (util-linux 2.32.1).
Changes will remain in memory only until you decide to write them.
Be careful before using the write command.

Command (m for help): _`;
                } else {
                    return "Please complete the previous steps first.";
                }
            }
            return `fdisk: cannot open ${args[0]}: No such file or directory`;
        },
        
        'partx': (args) => {
            if (args[0] === "-a" && args[1] === "/dev/sda") {
                if (currentStep === 2 || currentStep > 2) {
                    stepCommandsExecuted[2]['partx'] = true;
                    return "";
                } else {
                    return "Please complete the previous steps first.";
                }
            }
            return `partx: /dev/sda: failed to add partitions`;
        },
        
        'partprobe': () => {
            if (currentStep === 2 || currentStep > 2) {
                stepCommandsExecuted[2]['partprobe'] = true;
                
                // Check if both commands for step 2 have been executed
                if (stepCommandsExecuted[2]['partx'] && stepCommandsExecuted[2]['partprobe']) {
                    configState.partitionCreated = true;
                    configState.partitionType = true;
                    updateRequirements();
                    completeStep(2);
                }
                return "";
            } else {
                return "Please complete the previous steps first.";
            }
        },
        
        'mkswap': (args) => {
            if (args[0] && (args[0] === "/dev/sda8" || args[0] === "/dev/sda")) {
                if (currentStep === 3 || currentStep > 3) {
                    configState.mkswap = true;
                    updateRequirements();
                    completeStep(3);
                    return `Setting up swapspace version 1, size = 2 GiB (2147479552 bytes)
UUID=8d1567e8-3c1a-4a3d-9c2b-1f3d4e5f6a7d`;
                } else {
                    return "Please complete the previous steps first.";
                }
            }
            return `mkswap: ${args[0]}: invalid swap partition`;
        },
        
        'swapon': (args) => {
            if (args[0] === "-a") {
                if (currentStep === 4 || currentStep > 4) {
                    stepCommandsExecuted[4]['swapon-a'] = true;
                    configState.swapon = true;
                    updateRequirements();
                    return "";
                } else {
                    return "Please complete the previous steps first.";
                }
            } else if (args[0] === "-s") {
                if (currentStep === 4 || currentStep > 4) {
                    stepCommandsExecuted[4]['swapon-s'] = true;
                    
                    // Check if both commands for step 4 have been executed
                    if (stepCommandsExecuted[4]['swapon-a'] && stepCommandsExecuted[4]['swapon-s']) {
                        completeStep(4);
                    }
                    
                    let output = "Filename\t\t\tType\t\tSize\tUsed\tPriority\n";
                    output += "/dev/sda3\t\t\tpartition\t2097148\t0\t-2\n";
                    if (configState.swapon) {
                        output += `/dev/sda${fdiskState.partitionNumber}\t\t\tpartition\t2097148\t0\t-3\n`;
                    }
                    return output;
                } else {
                    return "Please complete the previous steps first.";
                }
            } else if (args[0] && (args[0] === "/dev/sda8" || args[0] === "/dev/sda")) {
                // Direct swapon command (not in requirements but should work)
                configState.swapon = true;
                updateRequirements();
                return "";
            }
            return `swapon: ${args[0]}: invalid argument`;
        },
        
        'blkid': (args) => {
            if (args[0] && (args[0] === "/dev/sda8" || args[0] === "/dev/sda")) {
                if (currentStep === 5 || currentStep > 5) {
                    return `/dev/sda${fdiskState.partitionNumber}: UUID="8d1567e8-3c1a-4a3d-9c2b-1f3d4e5f6a7d" TYPE="swap"`;
                } else {
                    return "Please complete the previous steps first.";
                }
            }
            return `blkid: ${args[0]}: No such file or directory`;
        },
        
        'vim': (args) => {
            if (args.length === 0) {
                return "vim: Please specify a file to edit";
            }
            
            const file = args[0];
            let content = '';
            
            if (file === "/etc/fstab") {
                content = fstabContent;
                if (currentStep === 5 || currentStep > 5) {
                    const result = openVimEditor(file, content, 'fstab');
                    return result;
                } else {
                    return "Please complete the previous steps first.";
                }
            }
            
            return `vim: cannot open ${file} for writing: No such file or directory`;
        },
        
        'cat': (args) => {
            if (args[0] === "/etc/fstab") {
                if (currentStep === 6 || currentStep > 6) {
                    stepCommandsExecuted[6]['cat-fstab'] = true;
                    checkStep6Completion();
                }
                return fstabContent;
            }
            return `cat: ${args[0]}: No such file or directory`;
        },
        
        'free': (args) => {
            if (args[0] === "-h") {
                if (currentStep === 6 || currentStep > 6) {
                    stepCommandsExecuted[6]['free-h'] = true;
                    checkStep6Completion();
                }
                
                let output = "              total        used        free      shared  buff/cache   available\n";
                output += "Mem:           1.9G        1.1G        120M         15M        780M        680M\n";
                output += "Swap:          2.0G          0B        2.0G\n";
                if (configState.swapon) {
                    output += "Swap:          4.0G          0B        4.0G\n";
                }
                return output;
            }
            return `free: invalid option -- '${args[0]}'`;
        },
        
        'clear': () => {
            terminalOutput.innerHTML = '';
            return '';
        },
        
        'help': () => {
            return "Available commands: fdisk, partx, partprobe, mkswap, swapon, blkid, vim, cat, free, clear, help";
        }
    };
    
    // Function to check if step 6 is complete
    function checkStep6Completion() {
        if (stepCommandsExecuted[6]['swapon-s'] && 
            stepCommandsExecuted[6]['free-h'] && 
            stepCommandsExecuted[6]['cat-fstab']) {
            completeStep(6);
        }
    }
    
    // Function to open the Vim editor
    function openVimEditor(filename, content, fileType) {
        vimState.file = filename;
        vimState.content = content;
        vimState.initialContent = content;
        vimState.fileType = fileType;
        vimState.mode = 'command';
        vimState.isEditing = true;
        
        // Set the filename in the editor
        vimFilename.textContent = filename;
        
        // Set the content in the textarea and readonly div
        vimTextarea.value = content;
        vimReadonly.textContent = content;
        
        // Set up instructions based on file type
        if (fileType === 'fstab') {
            vimInstructionsContent.innerHTML = `
                <p>Edit the fstab file to add an entry for your swap partition.</p>
                <p>Add a line like this (using the UUID from mkswap output):</p>
                <div class="file-content">UUID=8d1567e8-3c1a-4a3d-9c2b-1f3d4e5f6a7d none swap sw 0 0</div>
                <p><strong>Vim Commands:</strong></p>
                <ul>
                    <li>Press <code>i</code> to enter Insert mode</li>
                    <li>Type the required configuration</li>
                    <li>Press <code>ESC</code> to return to Command mode</li>
                    <li>Type <code>:wq</code> and press <code>Enter</code> to save and exit</li>
                </ul>
            `;
        }
        
        // Show the Vim overlay
        vimOverlay.style.display = 'flex';
        
        // Start in command mode
        switchToCommandMode();
        
        // Focus the vim input (command line)
        setTimeout(() => {
            vimInput.focus();
            updateVimCursorPosition();
        }, 100);
        
        return `Opening ${filename} in Vim editor...`;
    }
    
    // Function to switch to command mode
    function switchToCommandMode() {
        vimState.mode = 'command';
        vimModeIndicator.textContent = 'COMMAND MODE';
        vimModeIndicator.className = 'vim-mode-indicator command-mode';
        
        // Hide textarea, show readonly div
        vimTextarea.style.display = 'none';
        vimReadonly.style.display = 'block';
        vimTextarea.blur();
        vimInput.focus();
        
        // Update readonly content to match textarea
        vimReadonly.textContent = vimTextarea.value;
        updateVimCursorPosition();
    }
    
    // Function to switch to insert mode
    function switchToInsertMode() {
        vimState.mode = 'insert';
        vimModeIndicator.textContent = 'INSERT MODE';
        vimModeIndicator.className = 'vim-mode-indicator insert-mode';
        
        // Show textarea, hide readonly div
        vimTextarea.style.display = 'block';
        vimReadonly.style.display = 'none';
        vimInput.blur();
        vimTextarea.focus();
        
        // Set cursor position
        updateVimCursorPosition();
    }
    
    // Function to handle Vim commands
    function handleVimCommand(command) {
        if (command === 'w' || command === 'write') {
            // Save the file
            if (vimState.file === "/etc/fstab") {
                fstabContent = vimTextarea.value;
                if (fstabContent.includes("UUID=8d1567e8-3c1a-4a3d-9c2b-1f3d4e5f6a7d") || 
                    fstabContent.includes("swap swap")) {
                    configState.fstab = true;
                    updateRequirements();
                    completeStep(5);
                }
            }
            return "File saved";
        } else if (command === 'q' || command === 'quit') {
            // Close the editor
            closeVimEditor();
            return "";
        } else if (command === 'wq') {
            // Save and quit
            const saveMsg = handleVimCommand('w');
            closeVimEditor();
            return saveMsg + " and exiting";
        } else if (command === 'q!') {
            // Quit without saving
            closeVimEditor();
            return "Exiting without saving";
        } else if (command === 'i') {
            // Switch to insert mode
            switchToInsertMode();
            return "";
        }
        return `Not an editor command: ${command}`;
    }
    
    // Function to close the Vim editor
    function closeVimEditor() {
        vimOverlay.style.display = 'none';
        vimState.isEditing = false;
        commandInput.focus();
    }
    
    // Function to update Vim cursor position display
    function updateVimCursorPosition() {
        if (vimState.mode === 'insert') {
            const text = vimTextarea.value;
            const cursorPos = vimTextarea.selectionStart;
            const lines = text.substring(0, cursorPos).split('\n');
            const line = lines.length;
            const column = lines[lines.length - 1].length + 1;
            vimCursorPosition.textContent = `${line},${column}`;
        } else {
            // In command mode, just show 1,1
            vimCursorPosition.textContent = '1,1';
        }
    }
    
    // Function to update requirements display
    function updateRequirements() {
        if (configState.partitionCreated) {
            document.getElementById('req-partition-created').classList.add('completed');
            document.getElementById('req-partition-created').querySelector('.requirement-checkbox').textContent = '‚úì';
        }
        
        if (configState.partitionType) {
            document.getElementById('req-partition-type').classList.add('completed');
            document.getElementById('req-partition-type').querySelector('.requirement-checkbox').textContent = '‚úì';
        }
        
        if (configState.mkswap) {
            document.getElementById('req-mkswap').classList.add('completed');
            document.getElementById('req-mkswap').querySelector('.requirement-checkbox').textContent = '‚úì';
        }
        
        if (configState.swapon) {
            document.getElementById('req-swapon').classList.add('completed');
            document.getElementById('req-swapon').querySelector('.requirement-checkbox').textContent = '‚úì';
        }
        
        if (configState.fstab) {
            document.getElementById('req-fstab').classList.add('completed');
            document.getElementById('req-fstab').querySelector('.requirement-checkbox').textContent = '‚úì';
        }
        
        // Update progress
        const completedCount = Object.values(configState).filter(v => v).length;
        const progressPercent = (completedCount / Object.keys(configState).length) * 100;
        progressFill.style.width = `${progressPercent}%`;
        progressText.textContent = `${Math.round(progressPercent)}% Complete`;
        
        // Show completion message if all requirements are met
        if (completedCount === Object.keys(configState).length) {
            completionMessage.style.display = 'block';
        }
    }
    
    // Function to complete a step
    function completeStep(step) {
        if (step === currentStep) {
            steps[step].classList.remove('current');
            steps[step].classList.add('completed');
            steps[step].querySelector('.step-status').textContent = 'Completed';
            steps[step].querySelector('.step-status').className = 'step-status status-completed';
            
            currentStep++;
            
            if (currentStep < steps.length) {
                steps[currentStep].classList.add('current');
                steps[currentStep].querySelector('.step-status').textContent = 'Current Step';
                steps[currentStep].querySelector('.step-status').className = 'step-status status-current';
                
                // Update terminal with next step info
                addTerminalOutput(`[root@station ~]# Step ${step} completed. Moving to step ${currentStep}.`);
                
                // Show the command for the next step if available
                if (stepCommands[currentStep]) {
                    addTerminalOutput(`[root@station ~]# Next: ${stepCommands[currentStep][0]}`);
                }
            }
        }
    }
    
    // Function to add output to the terminal
    function addTerminalOutput(text) {
        const newLine = document.createElement('div');
        newLine.innerHTML = text;
        terminalOutput.appendChild(newLine);
        terminalOutput.scrollTop = terminalOutput.scrollHeight;
    }
    
    // Function to handle command execution
    function executeCommand(input) {
        const trimmedInput = input.trim();
        if (!trimmedInput) return;
        
        // Add to command history
        commandHistory.push(trimmedInput);
        historyIndex = commandHistory.length;
        
        // Display the command in terminal
        addTerminalOutput(`<span class="prompt">[root@station ~]#</span> ${trimmedInput}`);
        
        // Parse command and arguments
        const parts = trimmedInput.split(' ');
        const command = parts[0];
        const args = parts.slice(1);
        
        // Special handling for swapon -s in step 6
        if (command === 'swapon' && args[0] === '-s' && currentStep === 6) {
            stepCommandsExecuted[6]['swapon-s'] = true;
            checkStep6Completion();
        }
        
        // Execute command if it exists
        if (commands.hasOwnProperty(command)) {
            const result = commands[command](args);
            if (result) {
                addTerminalOutput(result);
            }
        } else {
            addTerminalOutput(`bash: ${command}: command not found`);
            addTerminalOutput('Type "help" for available commands');
        }
    }
    
    // Function to handle tab completion
    function handleTabCompletion() {
        const input = commandInput.value;
        
        // If this is a consecutive tab press with no change in input, cycle through options
        if (input === lastTabInput && tabCompletionItems.length > 1) {
            tabCompletionIndex = (tabCompletionIndex + 1) % tabCompletionItems.length;
            showTabCompletion(tabCompletionItems, tabCompletionIndex);
            return;
        }
        
        lastTabInput = input;
        const parts = input.split(' ');
        const lastPart = parts[parts.length - 1];
        
        // Reset tab completion state for new input
        tabCompletionIndex = 0;
        
        // If no input, show all available commands
        if (parts.length === 1 && lastPart === '') {
            tabCompletionItems = availableCommands;
            showTabCompletion(tabCompletionItems, 0);
            return;
        }
        
        // If it's a command completion
        if (parts.length === 1) {
            tabCompletionItems = availableCommands.filter(cmd => 
                cmd.startsWith(lastPart)
            );
            
            if (tabCompletionItems.length > 0) {
                showTabCompletion(tabCompletionItems, 0);
            } else {
                hideTabCompletion();
            }
            return;
        }
        
        // If it's a path completion
        const pathParts = lastPart.split('/');
        let basePath = pathParts.slice(0, -1).join('/') || '/';
        const partialName = pathParts[pathParts.length - 1];
        
        // Normalize base path
        if (!basePath.endsWith('/') && basePath !== '/') {
            basePath += '/';
        }
        
        // Get available completions for this path
        const availablePaths = filePaths[basePath] || [];
        tabCompletionItems = availablePaths.filter(path => 
            path.startsWith(partialName)
        );
        
        if (tabCompletionItems.length > 0) {
            showTabCompletion(tabCompletionItems, 0);
        } else {
            hideTabCompletion();
        }
    }
    
    // Function to show tab completion suggestions
    function showTabCompletion(items, selectedIndex) {
        if (items.length === 0) {
            hideTabCompletion();
            return;
        }
        
        // If only one item, auto-complete
        if (items.length === 1) {
            completeWithSuggestion(items[0]);
            hideTabCompletion();
            return;
        }
        
        // Create completion items
        tabCompletion.innerHTML = '';
        items.forEach((item, index) => {
            const div = document.createElement('div');
            div.className = `tab-completion-item ${index === selectedIndex ? 'selected' : ''}`;
            div.textContent = item;
            div.addEventListener('click', () => {
                completeWithSuggestion(item);
                hideTabCompletion();
            });
            tabCompletion.appendChild(div);
        });
        
        // Show the completion box
        tabCompletion.style.display = 'block';
        
        tabCompletionIndex = selectedIndex;
        tabCompletionItems = items;
    }
    
    // Function to hide tab completion
    function hideTabCompletion() {
        tabCompletion.style.display = 'none';
        tabCompletionItems = [];
        tabCompletionIndex = -1;
    }
    
    // Function to complete the input with a suggestion
    function completeWithSuggestion(suggestion) {
        const input = commandInput.value;
        const parts = input.split(' ');
        const lastPart = parts[parts.length - 1];
        
        if (parts.length === 1) {
            // Command completion
            commandInput.value = suggestion + ' ';
        } else {
            // Path completion
            const pathParts = lastPart.split('/');
            const basePath = pathParts.slice(0, -1).join('/');
            
            if (basePath) {
                parts[parts.length - 1] = basePath + '/' + suggestion;
            } else {
                parts[parts.length - 1] = suggestion;
            }
            
            commandInput.value = parts.join(' ') + (suggestion.endsWith('/') ? '' : ' ');
        }
        
        // Move cursor to end
        commandInput.selectionStart = commandInput.selectionEnd = commandInput.value.length;
        lastTabInput = commandInput.value;
    }
    
    // Event listeners
    commandInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            executeCommand(commandInput.value);
            commandInput.value = '';
            hideTabCompletion();
            lastTabInput = '';
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (commandHistory.length > 0) {
                if (historyIndex > 0) {
                    historyIndex--;
                }
                commandInput.value = commandHistory[historyIndex] || '';
            }
            hideTabCompletion();
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (historyIndex < commandHistory.length - 1) {
                historyIndex++;
                commandInput.value = commandHistory[historyIndex];
            } else {
                historyIndex = commandHistory.length;
                commandInput.value = '';
            }
            hideTabCompletion();
        } else if (e.key === 'Tab') {
            e.preventDefault();
            handleTabCompletion();
        } else if (e.key === 'Escape') {
            hideTabCompletion();
        } else {
            // Hide tab completion on other key presses if input changes
            setTimeout(() => {
                if (commandInput.value !== lastTabInput) {
                    hideTabCompletion();
                }
            }, 0);
        }
    });
    
    // Hide tab completion when clicking outside
    document.addEventListener('click', (e) => {
        if (!tabCompletion.contains(e.target) && e.target !== commandInput) {
            hideTabCompletion();
        }
    });
    
    // Vim editor event listeners
    vimCloseBtn.addEventListener('click', () => {
        closeVimEditor();
    });
    
    vimEscButton.addEventListener('click', () => {
        switchToCommandMode();
    });
    
    vimInsertButton.addEventListener('click', () => {
        switchToInsertMode();
    });
    
    // Handle vim mode switching with keyboard in textarea
    vimTextarea.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            e.preventDefault();
            switchToCommandMode();
        }
        updateVimCursorPosition();
    });
    
    vimTextarea.addEventListener('keyup', () => {
        if (vimState.mode === 'insert') {
            updateVimCursorPosition();
        }
    });
    
    // Handle vim command input
    vimInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            const command = vimInput.value.trim();
            if (command === 'i') {
                // Switch to insert mode
                switchToInsertMode();
                vimInput.value = '';
            } else if (command.startsWith(':')) {
                // Handle colon commands
                const actualCommand = command.substring(1);
                const result = handleVimCommand(actualCommand);
                if (result) {
                    addTerminalOutput(result);
                }
                vimInput.value = '';
            } else if (command) {
                // Other vim commands in command mode
                vimInput.value = '';
            }
        } else if (e.key === 'i' && vimInput.value === '' && vimState.mode === 'command') {
            // Quick insert mode switch
            e.preventDefault();
            switchToInsertMode();
        }
    });
    
    vimContent.addEventListener('click', () => {
        if (vimState.mode === 'command') {
            // In command mode, clicking should focus command input
            vimInput.focus();
        } else {
            vimTextarea.focus();
        }
    });
    
    // Initialize the lab
    updateRequirements();
</script>
</body>
</html>